## 시간복잡도란

-  1억번 연산하면 1초에 시간이 걸린다고 생각
-  시간제한이 2초라면? 2억번의 연산안에 답이 나와야한다.

## 유형

-  빅오메가: 최선일때의 연산횟수
-  빅세타: 보통일때의 연산횟수
-  빅오: 최악일때의 연산횟수

-  항상 모든 경우에 대해 최악의 경우를 택해야한다.
-  다양한 테스트 케이스를 수행해 모든 케이스를 통과해야한 합격이기 때문에

### 시간복잡도 순

-  O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!)
-  내가 짠 코드가 어떤 시간복잡도를 가지는지 알아랴함

### 연산횟수 계산 방법

-  연산횟수 = 알고리즘 시간복잡도 \* 데이터의 크기

### 예시

> 1 <= N <= 1,000,000 의 요소를 가진 숫자 배열이 있을때 해당 배열을 정렬하는 문제 (시간제한 2초)

-  버블정렬: O(n^2)
-  1,000,000^2 = 1,000,000,000,000 = 1조
-  1조번의 연산을 수행해야한다.

-  병합정렬: O(nlogn)
-  1,000,000log1,000,000 = 1,000,000 \* 20 = 20,000,000
-  2천만번의 연산을 수행해야한다.

-  위 문제의 시간제한은 2초이므로 1조번의 연산을 수행하는 버블정렬은 시간초과가 발생한다.
-  2천만번의 연산을 수행하는 병합정렬은 시간초과가 발생하지 않는다.

## 로직 개선하기

### 도출 기준

-  상수는 시간복잡도에서 제외한다.
-  가장 많이 중첩된 반복문의 수행횟수가 시간복잡도의 기준이 된다.
-  일반적인 for문 10개가 있더라도 중첩된 for문 하나가 더 시간복잡도가 크다.

1. 알맞은 알고리즘 선택하기
2. 비효율적인 로직 찾아서 효율적인 로직으로 교체
3. 메모리 초과일경우 저장된 값이 너무 많은 것
