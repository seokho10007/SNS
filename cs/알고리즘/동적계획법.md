# 동적 계획법

-  복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제 들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법
-  동적 계획법은 부분 문제들의 답을 저장해놓고 재활용하는 방식으로 계산량을 줄임으로써 효율적으로 문제를 해결하는 방법이다.

## 핵심 이론

1. 최적 부분 구조
   -  문제의 최적해가 부분 문제의 최적해로부터 구성될 수 있을 때, 최적 부분 구조를 가진다고 한다.
2. 중복되는 부분 문제
   -  동일한 부분 문제가 반복적으로 계산되는 경우, 중복되는 부분 문제를 가진다고 한다.
3. Memoization
   -  동일한 부분 문제가 반복적으로 계산되는 경우, 한 번 계산한 결과를 메모리에 저장해두고 이를 재활용하는 방식을 말한다.
4. 점화식
   -  점화식은 재귀적인 관계를 표현하는 방정식을 말한다.
5. Top-down 방식
   -  큰 문제를 해결하기 위해 작은 문제를 호출하는 방식을 말한다.

### 파보나치 수열

-  피보나치 수열이란? 0과 1로 시작하고, 다음 번째 수는 바로 앞의 두 수의 합인 수열을 말한다.
-  피보나치 수열은 다음과 같은 점화식을 가진다.

```js
f(n) = f(n-1) + f(n-2)
```

-  이 점화식을 이용하여 피보나치 수열을 구현하면 다음과 같다.

```js
function fibo(n) {
	if (n <= 1) return n;
	return fibo(n - 1) + fibo(n - 2);
}
```

-  위의 코드는 n이 커질수록 연산량이 기하급수적으로 증가하게 된다.
-  이는 중복되는 부분 문제를 가지고 있기 때문이다.
-  따라서, 동적 계획법을 이용하여 중복되는 부분 문제를 해결해야 한다.

```js
const memo = [];

function fibo(n) {
	if (n <= 1) return n;
	if (memo[n] > 0) return memo[n];
	memo[n] = fibo(n - 1) + fibo(n - 2);
	return memo[n];
}

fibo(10); // 55
```

1. 동적 계획법으로 풀 수 있는지 확인
   -  6 번째 피보나치 수열을 구한다고 가정
   -  6 번째 피보나치 수열은 5 번째 피보나치 수열과 4 번째 피보나치 수열의 합이다.
   -  즉, 큰 문제를 작은 부분의 문제로 쪼갤 수 있다.
2. 점화식 세우기
   -  논리적으로 전체 문제를 나누고, 전체 문제와 부분 문제 강의 인과 관계를 파악하는 훈련이 필요함
   -  큰 문제가 있으면 부분의 문제가 해결됐다고 가정하고 점화식을 세워야 한다.
   -  6번 째 수열: 1 ~ 5번 째 까지 다 구해졌다고 생각
3. 메모이제이션 원리 이해하기
   -  메모이제이션은 동일한 계산을 반복할 때, 이전에 계산한 값을 메모리에 저장하여 중복 계산을 방지하는 기술이다.
   -  메모이제이션은 동적 계획법의 핵심이다.
4. Top-down 방식으로 구현하기
   -  Top-down 방식은 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식을 말한다.
   -  Top-down 방식은 재귀 함수를 이용하여 구현한다.

### 1로 만들기

-  정수 X가 주어질 때, 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.
   1. X가 5로 나누어 떨어지면, 5로 나눈다.
   2. X가 3으로 나누어 떨어지면, 3으로 나눈다.
   3. X가 2로 나누어 떨어지면, 2로 나눈다.
   4. X에서 1을 뺀다.
-  정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 값을 1로 만들고자 한다.
-  연산을 사용하는 횟수의 최솟값을 출력하시오.

```js
function makeOne(x) {
	if (x === 1) return 0;
	if (memo[x] > 0) return memo[x];
	memo[x] = makeOne(x - 1) + 1;
	if (x % 2 === 0) {
		const temp = makeOne(x / 2) + 1;
		if (memo[x] > temp) memo[x] = temp;
	}
	if (x % 3 === 0) {
		const temp = makeOne(x / 3) + 1;
		if (memo[x] > temp) memo[x] = temp;
	}
	if (x % 5 === 0) {
		const temp = makeOne(x / 5) + 1;
		if (memo[x] > temp) memo[x] = temp;
	}
	return memo[x];
}

const memo = [];

makeOne(26); // 3
```

### 주의할 점

-  동적 계획법을 사용할 때, 재귀 함수를 이용하여 구현하면 메모리 초과가 발생할 수 있다.
-  탑다운 방식은 재귀 함수를 이용하므로 메모리 초과가 발생할 수 있다.
-  해당 경우 효율적인 방법은 바텀업 방식을 이용하는 것이다.
-  바텀업 방식은 반복문을 이용하여 구현한다.
