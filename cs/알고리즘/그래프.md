# 그래프

-  노드와 앳지로 구성된 집합
-  노드: 데이터를 표현하는 단위
-  엣지: 노드를 연결

## 그래프 알고리즘 목록

-  유니온 파인드: 그래프의 사이클이 생성되는지 판별하는 알고리즘
-  위상 정렬: 사이클이 없는 방향이 있는 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 알고리즘
-  다익스트라: 최단 경로를 찾는 알고리즘, s라는 시작점에서 모든 노드까지의 최단 경로를 구하는 알고리즘, 음수 간선이 없을 때 정상적으로 동작
-  벨만-포드: 최단 경로를 찾는 알고리즘, 음수 간선이 포함된 그래프에서도 사용 가능
-  플로이드-워셜: 최단 경로를 찾는 알고리즘, 모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산
-  최소신장트리: 그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 찾는 알고리즘

테이블

| 알고리즘      | 시간 복잡도(E: 간선의 개수, V: 노드의 개수) | 공간 복잡도 | 특징                             |
| ------------- | ------------------------------------------- | ----------- | -------------------------------- |
| 유니온 파인드 | O(V)                                        | O(V)        | 사이클 판별                      |
| 위상 정렬     | O(V + E)                                    | O(V)        | 사이클 판별                      |
| 다익스트라    | O(ElogV)                                    | O(V)        | 음수 간선 불가능                 |
| 벨만-포드     | O(VE)                                       | O(V)        | 음수 간선 가능                   |
| 플로이드-워셜 | O(V^3)                                      | O(V^2)      | 음수 간선 불가능                 |
| 최소신장트리  | O(ElogV)                                    | O(E)        | 크루스칼 알고리즘, 프림 알고리즘 |

## 그래프의 표현

### 엣지 리스트

-  엣지를 중심으로 그래프를 표현
-  배열에서 출발노드, 도착노드, (가중치)를 저장

#### 가중치가 없는 그래프 표현하기

-  출발노드와 도착노드만 표현하므로 배열의 행은 2개만 필요
-  엣지의 개수만큼 행이 필요하므로 엣지의 개수만큼 행을 가진 배열을 생성

```js
const graph = [
	[0, 1],
	[1, 2],
	[1, 3],
	[2, 3],
	[2, 4],
	[3, 4],
	[3, 5],
	[5, 6],
];
```

#### 가중치가 있는 그래프 표현하기

-  출발노드, 도착노드, 가중치를 표현하므로 배열의 행은 3개 필요
-  엣지의 개수만큼 행이 필요하므로 엣지의 개수만큼 행을 가진 배열을 생성

```js
const graph = [
	[0, 1, 7],
	[1, 2, 5],
	[1, 3, 9],
	[2, 3, 8],
	[2, 4, 7],
	[3, 4, 5],
	[3, 5, 15],
	[5, 6, 8],
];
```

### 인접 행렬

-  2차원 배열의 자료구조를 이용하여 표현
-  노드 중심으로 그래프를 표현
-  노드와 관련되어 탐색하려면 N번의 탐색이 필요
-  따라서, 노드의 개수에 비해 엣지의 개수가 적다면 공간 효츌성이 떨어짐
-  노드의 개수에 따라 사용여부를 결정하는 것이 좋음

#### 가중치가 없는 그래프 표현하기

-  노드의 개수만큼 행과 열을 가진 2차원 배열을 생성

```js
const graph = [
	[0, 1, 0, 0, 0, 0, 0],
	[1, 0, 1, 1, 0, 0, 0],
	[0, 1, 0, 0, 1, 0, 0],
	[0, 1, 0, 0, 1, 1, 1],
	[0, 0, 1, 1, 0, 0, 0],
	[0, 0, 0, 1, 0, 0, 1],
	[0, 0, 0, 1, 0, 1, 0],
];
```

-  ex) 0번 노드와 1번 노드는 연결되어 있으므로 graph[0][1]의 값은 1
-  ex) 0번 노드와 2번 노드는 연결되어 있지 않으므로 graph[0][2]의 값은 0

#### 가중치가 있는 그래프 표현하기

-  노드의 개수만큼 행과 열을 가진 2차원 배열을 생성

```js
const graph = [
	[0, 7, 0, 0, 0, 0, 0],
	[7, 0, 5, 9, 0, 0, 0],
	[0, 5, 0, 0, 7, 0, 0],
	[0, 9, 0, 0, 8, 5, 15],
	[0, 0, 7, 8, 0, 0, 0],
	[0, 0, 0, 5, 0, 0, 8],
	[0, 0, 0, 15, 0, 8, 0],
];
```

-  ex) 0번 노드와 1번 노드는 연결되어 있으므로 graph[0][1]의 값은 7
-  ex) 0번 노드와 2번 노드는 연결되어 있지 않으므로 graph[0][2]의 값은 0

### 인접 리스트

-  연결 리스트 자료구조를 이용하여 표현
-  엣지를 중심으로 그래프를 표현
-  노드와 관련되어 탐색하려면 엣지의 개수만큼 탐색이 필요
-  따라서, 엣지의 개수에 비해 노드의 개수가 적다면 공간 효츌성이 떨어짐

#### 가중치가 없는 그래프 표현하기

-  노드의 개수만큼 인접 리스트를 생성

```js
const graph = [[1], [0, 2, 3], [1, 4], [1, 4, 5, 6], [2, 3], [3, 6], [3, 5]];
```

#### 가중치가 있는 그래프 표현하기

-  노드의 개수만큼 인접 리스트를 생성

```js
const graph = [
	[[1, 7]],
	[
		[0, 7],
		[2, 5],
		[3, 9],
	],
	[
		[1, 5],
		[4, 7],
	],
	[
		[1, 9],
		[4, 8],
		[5, 5],
		[6, 15],
	],
	[
		[2, 7],
		[3, 8],
	],
	[
		[3, 5],
		[6, 8],
	],
	[
		[3, 15],
		[5, 8],
	],
];
```

-  [노드, 가중치] 형태로 저장

## 유니온 파인드

-  여러 노드가 있을때 특정 2개 노드를 연결해 1개의 집합으로 묶는 union연산과 두 노드가 같은 집합에 속해있는지를 확인하는 find연산으로 구성
-  union 연산: 두 노드를 연결하는 연산
-  find 연산: 자신의 대표 노드를 찾아주는 연산

### 핵심이론

-  union 연산: 각 노드가 속한 집합을 1개로 합치는 연산, 노드 a, b가 a ∈ A, b ∈ B 일때, union(a, b) A ∪ B는 A와 B의 합집합
-  find 연산: 특정 노드 a에 관해 a가 속한 대표 노드를 반환하는 연산, 노드 a가 a ∈ A일떄, find(a)는 A의 대표 노드를 반환

### 원리

-  알고리즘 실행전 초기화 실행
-  항상 대표 노드끼리 연결

1. 유니온 파인드는 일반적으로 1차원 배열을 사용하여 구현, 처음에는 각 노드가 연결되어 있지 않으므로 각 노드가 대표노드가 됨
2. 2개의 노드를 선택해 각각의 대표노드를 찾아 같은지를 확인하는 find 연산을 수행
3. 2개의 노드를 선택해 각각의 대표노드를 찾아 연결하는 union 연산을 수행

#### find 연산의 작동원리

1. 대상 노드 배열에 index값과 value값이 동일한지 확인
2. 동일하지 않으면 value 값이 가리키는 index위치로 이동
3. index값과 value값이 동일할때까지 반복(대표노드를 찾을때까지 반복)
4. 재귀함수를 빠져나오면 거치는 모든 노드값들을 루트노드값으로 변경

### 구현

```js
const find = (target) => {
	if (target === parent[target]) return target;
	parent[target] = find(parent[target]);
	return parent[target];
};

const union = (a, b) => {
	const rootA = find(a);
	const rootB = find(b);
	if (rootA === rootB) return;
	if (rootA < rootB) parent[rootB] = rootA;
	else parent[rootA] = rootB;
};
```

## 위상정렬

-  사이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘
-  항상 유일한 값으로 정렬되지 않는다.
-  사이클이 존재하면 노드간의 순서를 명확하게 정할 수 없다.

| 기능                  | 특징               | 시간복잡도 |
| --------------------- | ------------------ | ---------- |
| 노드 간의 순서를 결정 | 사이클이 없어야 함 | O(V + E)   |

### 핵심이론

-  진입차수: 특정한 노드로 들어오는 간선의 개수
-  진출차수: 특정한 노드에서 나가는 간선의 개수
-  위상정렬: 진입차수가 0인 노드를 큐에 넣고 큐가 빌때까지 다음의 과정을 반복
   1. 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거
   2. 새롭게 진입차수가 0이 된 노드를 큐에 넣음

### 구현

```js
const graph = [[], [2, 5], [3], [4], [6], [6], []];

const topologySort = () => {
	const result = [];
	const q = [];
	const indegree = Array.from({ length: 7 }, () => 0);

	for (let i = 1; i < graph.length; i++) {
		for (let j = 0; j < graph[i].length; j++) {
			indegree[graph[i][j]]++;
		}
	}

	for (let i = 1; i < indegree.length; i++) {
		if (indegree[i] === 0) q.push(i);
	}

	while (q.length) {
		const now = q.shift();
		result.push(now);
		for (let i = 0; i < graph[now].length; i++) {
			indegree[graph[now][i]]--;
			if (indegree[graph[now][i]] === 0) q.push(graph[now][i]);
		}
	}

	return result;
};
```

-  진입차수 배열을 기준으로 그래프를 생성

## 다익스트라

-  최단거리를 구하는 알고리즘

| 기능                                   | 특징             | 시간복잡도 |
| -------------------------------------- | ---------------- | ---------- |
| 춟발노드와 모든 노드간의 최단거리 탐색 | 엣지는 모두 양수 | O(ElogN)   |

### 핵심 이론

1. 인접 리스트로 그래프 구현하기
   -  인접 행렬도 좋지만 시간복잡도 측면, 즉 N의 크기가 커질수록 인접 리스트가 유리
2. 최단거리 배열을 초기화
   -  출발노드는 0, 나머지는 무한대로 초기화
   -  왜? 출발노드에서 출발노드로 가는 최단거리는 0이기 때문
3. 값이 가장 작은 노드 고르기
4. 최단 거리 배열 업데이트
5. 3, 4번 과정 반복
   -  최단거리 배열이 모두 갱신될때까지 반복
   -  최단거리 배열이 모두 갱신되었다는 것은 모든 노드를 방문했다는 것을 의미
   -  선택노드가 될 때 마다 가시 선택되지 않도록 방문 배열을 만들어 처리

### 구현

```js
const graph = [
	[],
	[
		[2, 2],
		[3, 5],
		[4, 1],
	],
	[
		[3, 3],
		[4, 2],
	],
	[
		[2, 3],
		[6, 5],
	],
	[
		[3, 3],
		[5, 1],
	],
	[
		[3, 1],
		[6, 2],
	],
	[],
];

const dijkstra = (start) => {
	const distance = Array.from({ length: 7 }, () => Infinity);
	const visited = Array.from({ length: 7 }, () => false);

	distance[start] = 0;
	visited[start] = true;

	for (let i = 0; i < graph[start].length; i++) {
		const [next, dist] = graph[start][i];
		distance[next] = dist;
	}

	for (let i = 0; i < graph.length - 2; i++) {
		let min = Infinity;
		let now = -1;
		for (let j = 1; j < distance.length; j++) {
			if (!visited[j] && distance[j] < min) {
				min = distance[j];
				now = j;
			}
		}
		visited[now] = true;
		for (let j = 0; j < graph[now].length; j++) {
			const [next, dist] = graph[now][j];
			distance[next] = Math.min(distance[next], distance[now] + dist);
		}
	}

	return distance;
};
```

## 벨만포드

-  음의 간선이 포함된 상황에서의 최단 거리를 구하는 알고리즘
-  N개의 엣지를 사용했을때의 최단거리를 구할 수 있음

| 기능                                   | 특징                       | 시간복잡도 |
| -------------------------------------- | -------------------------- | ---------- |
| 춟발노드와 모든 노드간의 최단거리 탐색 | 음의 간선이 포함될 수 있음 | O(VE)      |

### 핵심 이론

1. 최단거리 배열을 초기화
   -  출발노드는 0, 나머지는 무한대로 초기화
   -  왜? 출발노드에서 출발노드로 가는 최단거리는 0이기 때문
2. 모든 엣지를 확인하며 최단거리 배열을 갱신
   -  모든 노드를 확인하며 최단거리 배열을 갱신
   -  N개의 엣지를 사용했을때의 최단거리를 구할 수 있음
   -  음의 간선이 포함될 수 있음
3. 2번 과정을 N-1번 반복
   -  N번째 반복에서도 최단거리 배열이 갱신된다면 음의 사이클이 존재하는 것
   -  음의 사이클이 존재한다면 최단거리를 구할 수 없음

### 구현

```js
const graph = [
	[],
	[
		[2, 2],
		[3, 5],
		[4, 1],
	],
	[
		[3, 3],
		[4, 2],
	],
	[
		[2, 3],
		[6, 5],
	],
	[
		[3, 3],
		[5, 1],
	],
	[
		[3, 1],
		[6, 2],
	],
	[],
];

const bellmanFord = (start) => {
	const distance = Array.from({ length: 7 }, () => Infinity);

	distance[start] = 0;

	for (let i = 0; i < graph.length - 1; i++) {
		for (let j = 1; j < graph.length; j++) {
			for (let k = 0; k < graph[j].length; k++) {
				const [next, dist] = graph[j][k];
				distance[next] = Math.min(distance[next], distance[j] + dist);
			}
		}
	}

	for (let j = 1; j < graph.length; j++) {
		for (let k = 0; k < graph[j].length; k++) {
			const [next, dist] = graph[j][k];
			if (distance[next] > distance[j] + dist) return false;
		}
	}

	return distance;
};
```

### 음수사이클 여부 확인하기

-  음수사이클이 존재한다면 최단거리를 구할 수 없음
-  N-1번의 연산을 수행한 뒤 한번의 연산을 더 실행했을 때 최단거리 배열이 갱신된다면 음수사이클이 존재하는 것

## 플로이드 워셜

-  모든 노드에서 모든 노드로 가는 최단거리를 구하는 알고리즘
-  다익스트라 알고리즘과 마찬가지로 단계별로 거쳐가는 노드를 기준으로 알고리즘을 수행
-  다만 매 단계마다 방문하지 않은 노드 중에 최단거리를 갖는 노드를 찾는 과정이 필요하지 않음
-  2차원 배열에 최단거리를 저장하며, 다이나믹 프로그래밍을 이용하여 거쳐가는 노드를 기준으로 최단거리를 구함

| 기능                                   | 특징                       | 시간복잡도 |
| -------------------------------------- | -------------------------- | ---------- |
| 춟발노드와 모든 노드간의 최단거리 탐색 | 음의 간선이 포함될 수 있음 | O(V^3)     |

### 핵심 이론

1. 2차원 배열을 초기화

   -  출발노드와 도착노드가 같다면 0, 아니라면 무한대로 초기화
   -  왜? 출발노드에서 출발노드로 가는 최단거리는 0이기 때문

2. 2차원 배열을 갱신

   -  모든 노드를 확인하며 최단거리 배열을 갱신
   -  N개의 엣지를 사용했을때의 최단거리를 구할 수 있음
   -  음의 간선이 포함될 수 있음

3. 2번 과정을 N번 반복

### 구현

```js
const graph = [
	[],
	[
		[2, 4],
		[4, 6],
	],
	[
		[1, 3],
		[3, 7],
	],
	[
		[1, 5],
		[2, 4],
	],
	[
		[3, 2],
		[2, 6],
	],
];

const floydWarshall = () => {
	const distance = Array.from({ length: 5 }, () => Array(5).fill(Infinity));

	for (let i = 1; i < graph.length; i++) {
		for (let j = 0; j < graph[i].length; j++) {
			const [next, dist] = graph[i][j];
			distance[i][next] = dist;
		}
	}

	for (let k = 1; k < graph.length; k++) {
		for (let i = 1; i < graph.length; i++) {
			for (let j = 1; j < graph.length; j++) {
				distance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);
			}
		}
	}

	return distance;
};
```
