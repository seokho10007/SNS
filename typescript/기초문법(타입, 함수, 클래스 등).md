본 내용은 타입스크립트 공식문서를 토대로 작성한 문서입니다.

# 기본 타입

## 소개 (Introdection)

TypeScript는 JavaScript와 거의 동일한 데이터 타입을 지원하며, 열거 타입을 사용하여 더 편리하게 사용할 수 있다.  
<br>

## 불리언 (Boolean)

참거짓을 나타내는 데이터 타입

```ts
let isDone: boolean = false;
```

<br>

## 숫자 (Number)

```ts
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
```

<br>

## 문자열 (String)

기본형

```ts
let color: string = 'blue';
color = 'red';
```

템플릿 문자열

```ts
let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${fullName}. I'll be ${age + 1} years old next month.`;
```

위 sentence 선언을 간추려 표현할 수 있다.

```ts
let sentence: string = `Hello, my name is ${fullName}. I'll be ${age + 1} years old next month.`;
```

<br>

## 배열 (Array)

기존 타입 뒤에 []을 추가

```ts
let list: number[] = [1, 2, 3];
```

제네릭 배열 타입을 통해서도 사용 가능

```ts
let list: Array<number> = [1, 2, 3];
```

<br>

## 튜플 (Tuple)

튜플 타입 사용 시, 요소의 타입과 개수가 고정된 배열을 표현 가능
단, 요소들의 타입이 모두 같을 필요가 없다.

```ts
// 튜플 타입으로 선언
let x: [string, number];
// 초기화
x = ['hello', 10];
// 잘못된 초기화
x = [10, 'hello'];
```

정해진 인덱스에 위치한 요소에 접근 시 해당 타입이 나타난다.

```ts
console.log(x[0].substring(1)); // 성공
console.log(x[1].substring(1)); // 실패
```

정해진 인덱스 외에 다른 인덱스에 있는 요소에 접근하면, 오류 발생

```ts
x[3] = 'world'; // 오류, '[string, number]' 타입에는 프로퍼티 '3'이 없습니다.

console.log(x[5].toString()); // '[string, number] 타입에는 프로퍼티 '5'가 없습니다.
```

<br>

## 열거 (Enum)

자바스크립트의 표준 자료형 집합과 사용하면 도움이 될만 데이터형이며, `enum` 은 값의 집합에 더 나은 이름을 붙일 수 있다.

```ts
enum Color {
	Red,
	Green,
	Blue,
}
let c: Color = Color.Green;
```

기본적으로, `enum` 은 `0` 부터 시작하여 맴버들의 번호를 매긴다. 맴버 중 하나의 값을 수동으로 설정하여 번호를 바꿀 수 있다.

```ts
enum Color = {Red: 1, Green, Blue}
let c: Color = Color.Green
```

또는, 모든 값을 수동으로 설정할 수 있다.

```ts
enum Color {
	Red = 1,
	Green = 2,
	Blue = 4,
}
let c: Color = Color.Green;
```

`enum` 의 유용한 기능 중 하나는 매겨진 값을 사용해 `enum` 맴버의 이름을 알아낼 수 있다. (배열처럼 사용가능)

```ts
enum Color {
	Red = 1,
	Green,
	Blue,
}
let colorName: string = Color[2];

console.log(colorName); // 값이 2인 'Green'이 출력된다.
```

<br>

## Any

어떤 타입이든 사용 가능

```ts
let notSure: any = 4;
motSure = 'maybe a string instead';
noSure = false; // 성공
```

타입의 일부만 알고 전체는 알지 못할 때 유용

```ts
let list: any[] = [1, true, 'free'];

list[1] = 100;
```

<br>

## Void

어떤 타입도 존재할 수 없음을 의미, `any` 의 반대 타입과 같다.
보통 함수에서 반환 값이 없을 때 반환 타입을 표현

```ts
function warnUser(): void {
	console.log('This is my warning message');
}
```

`void` 를 타입 변수 선언하는 것은 유요하지 않다.
그 변수에는 `null` 또는 `undefined` 만 할당할 수 있기 때문이다.

```ts
let unusable: void = undefined;
unusable = null; // 성공, '--stricNullChecks' 을 사용하지 않을때만
```

<br>

## Null and UndeFined

`null` 과 `undefined` 또한 타입으로 선언할 수 있다.  
동시에 허용하고 싶을 때는 유니언 타입인 `null | undefined` 를 통해 사용

```ts
let typeNull: null = null;
let typeUndefined: undefined = undefined;

type a = null | undefined;
let b: a = undefined;
b = null; // 성공
```

<br>

## Never

절대 발생할 수 없는 타입을 나타낸다.  
함수 표현식에 항상 오류를 발생시키거나 절대 반환하지 않는 반환 타입으로 쓰인다.  
변수 또한 타입 가드에 의해 아무 타입도 얻지 못하게 좁혀지면 `never` 타입을 얻게 된다.
<br>
`never` 타입은 모든 타입에 할당 가능한 하위 타입이다. 하지만 어떤 타입도 `never` 에 할당할 수 있거나, 하위 타입이 아니다. (`never` 자신 제외) 심지어 `any` 도 `never` 에 할당할 수 없다.

```ts
// never를 반환하는 함수는 함수의 마지막에 도달할 수없다.
function error(message: string): never {
	throw new Error(message);
}

// 반환 타입이 never호 추론된다. (:never를 입력하지 않아도)
function fail() {
	return error('Something failed');
}

// never를 반환하는 함수는 함수의 마지막에 도달할 수 없다.
function infiniteLoop(): never {
	while (true) {}
}
```

<br>

## 객체 (Object)

원시 타입(string, number, boolean 등)이 아닌 타입을 나타낸다.  
`object` 타입을 쓰면, `Object.create` 같은 API 가 더 잘 나타난다.

```ts
declare function create(o: object | null): void;
create({ prop: 0 }); // 성공
create(null); // 성공

create(42); // 오류
create('string'); // 오류
create(false); // 오류
create(undefined); // 오류
```

<br>

## 타입 단언 (Type assertions)

타입 선언 시 컴파일러는 해당 구문이 해당 타입에 적합한지 검사하는 과정을 거친다.  
하지만, 개발자가 타입 단언을 통해 해당 구문이 해당 타입이 맞다는 것을 단언하는 것이 타입 단언이다.  
"angle-bracket" 문법

```ts
let someValue: any = 'this is a stirng';

let strLength: number = (<string>someValue).length;
```

`as`-문법

```ts
let someValue: any = 'this is a string';

let strLength: number = (someValue as string).length;
```

어떤 것을 사용할 지는 주로 선호에 따르지만 Typescript를 JSX와 함께 사용할 때는, `as`-스타일의 단언만 허용된다.
