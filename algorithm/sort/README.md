선택정렬
- 가장 작은 것을 선택해서 앞으로 보냄
- N * (N + 1) / 2 번의 연산을 실행함
- 컴퓨터에서는 가장 큰 차수인 N^2만 보고 O(N^2)라고 표현

버블정렬
- 옆에 있는 값과 비교해서 더 작은 값을 앞으로 보냄
- 한번 반복했을때 가장 큰 값이 제일 뒤로 감
- 선택정렬과 같이 N^2의 시간복잡도를 가지만 효율성이 가장 떨어짐
- 버블정렬이 효율성이 가장 떨어지는 이유는 
- 선택정렬은 연산의 마지막에 요소를 교체, 버블정렬은 매 연산마다 뒤에 값과 값을 비교해 요소를 교체
- 컴퓨터의 실행시간이 훨씬 더 오래걸림

삽입정렬
- 각 숫자를 적절한 위치에 삽입하는 방법
- 다른 정렬 방신들은 무조건 위치를 바꾸지만 삽입정렬은 필요한때만 위치를 바꿈
- N^2 의 시간복잡도를 가지지만
- 연산이 적게 이루어져 선택정렬과 버블정렬보다 더 빠른 실행시간을 가짐
- 왼쪽에 있는 요소들은 정렬이 되어있다 가정함
- 특정한 상황에선 빠른 실행속도를 보임
- 거의 정렬된 상태라면 굉장히 빠르고 자원을 적게 소모함


퀵정렬
- N * logN 의 실행 속도를 평균으로 가지는 정렬 알고리즘
- 분할 정복 알고리즘을 사용
- 특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤에 배열을 반으로 나눔
- 퀵정렬에는 기준 값이 존재 (피벗)
- 보통 첫번째 원소를 피벗 값으로 설정
- 배열 왼쪽부터 피벗 값보다 큰 값을, 오른쪽부터 피벗 값보다 작은 값을 찾아 교체
- 피벗 값과 교체후 다시 연산 실행
- 퀵정렬은 평균적으로 빠른 알고리즘이지만 배열이 이미 정렬되어 있을경우
- N^2의 시간 복잡도를 지니게됨

병합정렬
- 분할 정복 방법을 채택한 알고리즘
- 같은 방법을 채택한 퀵정렬은 최악의 경우 N^2의 시간복잡도를 가진다.
- 병합 정렬은 정확히 반절씩 나눈다는 점에서 최악의 경우에도 N * logN의 시간복잡도를 보장
- 일단 반으로 나누고 나중에 합쳐서 정렬
- 이미 정렬이 되어있는 상태에서 새롭게 정렬된 상태를 만드는 것

ex) 
    7 6 5 8 3 5 9 1 // 하나씩 분리.  
      67 58 35 19 // 2개씩 정렬.  
       5678 1359 // 정렬.  
        13556789 // 정렬.  
